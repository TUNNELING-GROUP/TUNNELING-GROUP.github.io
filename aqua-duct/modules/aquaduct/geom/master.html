

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>aquaduct.geom.master &#8212; Aqua-Duct 1.0.10 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="shortcut icon" href="../../../_static/ficon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Aqua-Duct 1.0.10 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../aquaduct.html" >aquaduct</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geom.html" accesskey="U">aquaduct.geom</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">aquaduct.geom.master</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for aquaduct.geom.master</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># Aqua-Duct, a tool facilitating analysis of the flow of solvent molecules in molecular dynamic simulations</span>
<span class="c1"># Copyright (C) 2016-2018  Tomasz Magdziarz, Alicja Płuciennik, Michał Stolarczyk &lt;info@aquaduct.pl&gt;</span>
<span class="c1"># Copyright (C) 2019  Tomasz Magdziarz &lt;info@aquaduct.pl&gt;</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="c1"># this modlue is a prototype and has to be rewritten</span>

<span class="kn">from</span> <span class="nn">aquaduct</span> <span class="k">import</span> <span class="n">logger</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Process</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">zip_longest</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span><span class="p">,</span> <span class="n">pdist</span>

<span class="kn">from</span> <span class="nn">aquaduct.traj.paths</span> <span class="k">import</span> <span class="n">GenericPathTypeCodes</span><span class="p">,</span> <span class="n">GenericPaths</span><span class="p">,</span> <span class="n">yield_single_paths</span><span class="p">,</span> <span class="n">MasterPath</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils.helpers</span> <span class="k">import</span> <span class="n">list_blocks_to_slices</span><span class="p">,</span> <span class="n">strech_zip</span><span class="p">,</span> <span class="n">zip_zip</span><span class="p">,</span> <span class="n">xzip_xzip</span><span class="p">,</span> <span class="n">concatenate</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils</span> <span class="k">import</span> <span class="n">clui</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils.maths</span> <span class="k">import</span> <span class="n">make_default_array</span><span class="p">,</span> <span class="n">defaults</span>
<span class="kn">from</span> <span class="nn">aquaduct.traj.inlets</span> <span class="k">import</span> <span class="n">InletClusterGenericType</span><span class="p">,</span> <span class="n">InletClusterExtendedType</span>
<span class="kn">from</span> <span class="nn">aquaduct.traj.paths</span> <span class="k">import</span> <span class="n">PassingPath</span>
<span class="kn">from</span> <span class="nn">aquaduct.apps.data</span> <span class="k">import</span> <span class="n">GCS</span>

<span class="c1">################################################################################</span>
<span class="n">part2type_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">,</span>
                  <span class="mi">1</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">object_name</span><span class="p">,</span>
                  <span class="mi">2</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">}</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Part number to :class:`~aquaduct.traj.paths.GenericPathTypeCodes` dictionary.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="n">parts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Parts enumerate.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1">################################################################################</span>

<span class="n">fsrs_cache</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="CTypeSpathsCollectionWorker"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollectionWorker">[docs]</a><span class="k">class</span> <span class="nc">CTypeSpathsCollectionWorker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Worker class for averaging spaths in points of master path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spaths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias_long</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Core method for averaging spaths in to master path.</span>

<span class="sd">        Averaging is done in chunks.</span>

<span class="sd">        :param list spaths: List of separate paths to average.</span>
<span class="sd">        :param InletClusterGenericType ctype: CType of spaths.</span>
<span class="sd">        :param int bias_long: Bias towards long paths used in :meth:`lens_norm`.</span>
<span class="sd">        :param Smooth smooth: Smoothing method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span> <span class="o">=</span> <span class="n">spaths</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterGenericType</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterExtendedType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span> <span class="o">=</span> <span class="n">bias_long</span>  <span class="c1"># TODO: check if it is required here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens_real_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">lock</span>
        <span class="c1"># self.lock_required = False</span>

<div class="viewcode-block" id="CTypeSpathsCollectionWorker.coords_types_prob_widths"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollectionWorker.coords_types_prob_widths">[docs]</a>    <span class="k">def</span> <span class="nf">coords_types_prob_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sp_slices_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates average coordinates, type and width in given chunk.</span>

<span class="sd">        Parameter :attr:`sp_slices_` is tuple of length equal to number of spaths.</span>
<span class="sd">        It contains slices for all spaths respectively. With these slices spaths are cut and **only**</span>
<span class="sd">        resulting chunks are used for calculations.</span>

<span class="sd">        Therefore, this method average spaths in one point of master math. This point is defined by slices submitted as</span>
<span class="sd">        :attr:`sp_lices_` parameter.</span>

<span class="sd">        Algorithm of averaging (within current chunks of spaths):</span>

<span class="sd">        #. Coordinates for all spaths are collected.</span>
<span class="sd">        #. Lengths of all spaths are collected (from cached variables) and kept as lists of lengths equal to</span>
<span class="sd">           chunks&#39; sizes.</span>

<span class="sd">            .. note::</span>

<span class="sd">                Lengths of collected lengths of spaths are of the same size as coordinates</span>

<span class="sd">        #. New coordinates are calculated as weighted average of collected coordintates with :func:`numpy.average`.</span>
<span class="sd">           As weights collected lengths are used.</span>

<span class="sd">            .. note::</span>

<span class="sd">                Function :func:`numpy.average` is called with flatten coordinates and lengths.</span>

<span class="sd">        #. Width of average path is calculated as mean value of flatten coordinates mutual distances.</span>
<span class="sd">        #. Type of average paths is calculated as probability (frequency) of</span>
<span class="sd">           :attr:`~aquaduct.traj.paths.GenericPathTypeCodes.scope_name`.</span>

<span class="sd">        :param tuple sp_slices_: Slices that cut chunks from all paths.</span>
<span class="sd">        :rtype: 3 element tuple</span>
<span class="sd">        :return: coordinates, type (frequency), and width of averaged spaths in current point</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get zz coords, zz means zip_zip - for all spaths</span>
        <span class="n">coords_zz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">,</span> <span class="n">sp_slices_</span><span class="p">):</span>
            <span class="c1"># self.lock.acquire()</span>
            <span class="c1"># coords_zz_element = sp.get_coords_cont(smooth=self.smooth)</span>
            <span class="c1"># coords_zz.append(coords_zz_element[sl])</span>
            <span class="n">coords_zz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">get_coords_cont</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">)[</span><span class="n">sl</span><span class="p">])</span>
            <span class="c1"># self.lock.release()</span>

        <span class="c1"># make lens_zz which are lens corrected to the lenghts of coords_zz and normalized to zip_zip number of obejcts</span>
        <span class="n">lens_zz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">coord_z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span><span class="p">,</span> <span class="n">coords_zz</span><span class="p">):</span>
            <span class="c1"># l is lenght for one spath</span>
            <span class="c1"># coord_z are coordinates of this path (sliced to current chunk)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lens_zz</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_z</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_z</span><span class="p">))</span>  <span class="c1"># normalize and correct lengths</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># lens_zz.append([float(l)] * len(coord_z))</span>
                <span class="n">lens_zz</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="c1"># here we have coords_zz, lens_zz</span>
        <span class="c1"># and we can calculate coords, types_prob, widths</span>

        <span class="c1"># concatenate zip_zip coords and lens</span>
        <span class="n">coords_zz_cat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="o">*</span><span class="n">coords_zz</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">coords_zz</span>

        <span class="n">lens_zz_cat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="o">*</span><span class="n">lens_zz</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">lens_zz</span>
        <span class="c1"># average coords_zz_cat using weights of lens_zz_cat</span>

        <span class="n">coords_to_append</span> <span class="o">=</span> <span class="n">make_default_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">coords_zz_cat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">lens_zz_cat</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">lens_zz_cat</span>

        <span class="c1"># calculate widths</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># is the len of coords_zz the same as sp_slices_ and self.spaths?</span>
            <span class="n">widths_to_append</span> <span class="o">=</span> <span class="n">make_default_array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords_zz_cat</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)))</span>  <span class="c1"># TODO: this is probably the reason for memory hunger</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">widths_to_append</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">del</span> <span class="n">coords_zz_cat</span>

        <span class="c1"># concatenate zip_zip gtypes</span>
        <span class="n">types_zz_cat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">gtypes_cont</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">,</span> <span class="n">sp_slices_</span><span class="p">)]))</span>
        <span class="k">del</span> <span class="n">sp_slices_</span>
        <span class="c1"># append type porbability to types</span>

        <span class="n">types_to_append</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">types_zz_cat</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">types_zz_cat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coords_to_append</span><span class="p">,</span> <span class="n">types_to_append</span><span class="p">,</span> <span class="n">widths_to_append</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr_sp_slices_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callable interface.</span>

<span class="sd">        :param tuple nr_sp_slices_: Two element tuple: nr and sp_slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nr_sp_slices_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_types_prob_widths</span><span class="p">(</span><span class="n">nr_sp_slices_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="CTypeSpathsCollection"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection">[docs]</a><span class="k">class</span> <span class="nc">CTypeSpathsCollection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object for grouping separate paths that belong to the same CType.</span>
<span class="sd">    Method :meth:`get_master_path` allows for calculation of average path.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># spath parts</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Enumeration of spath parts.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># takes group of paths belonging to one ctype and allows to get MasterPath</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spaths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias_long</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">pbar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list spaths: List of separate paths.</span>
<span class="sd">        :param InletClusterGenericType ctype: CType of spaths.</span>
<span class="sd">        :param int bias_long: Bias towards long paths used in :meth:`lens_norm`.</span>
<span class="sd">        :param pbar: Progress bar object.</span>
<span class="sd">        :param int threads: Number of available threads.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="o">=</span> <span class="n">pbar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span>
        <span class="c1"># self.threads = 1 # force one thread</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Threads passed </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">threads</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span> <span class="o">=</span> <span class="n">spaths</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterGenericType</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterExtendedType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span> <span class="o">=</span> <span class="n">bias_long</span>

        <span class="c1"># precompute some values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;spaths props cache in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_real_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_real</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<div class="viewcode-block" id="CTypeSpathsCollection.beat"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.beat">[docs]</a>    <span class="k">def</span> <span class="nf">beat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Touch progress bar, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span><span class="o">.</span><span class="n">heartbeat</span><span class="p">()</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.update"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update progres bar by one, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span><span class="o">.</span><span class="n">next</span><span class="p">()</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.lens"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.lens">[docs]</a>    <span class="k">def</span> <span class="nf">lens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns total lengths of all paths.</span>

<span class="sd">        If ctype in #:# and not 0 and not None then take length of `object` part only.</span>

<span class="sd">        :return: Total (or `object` part) lengths of all paths.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">lens_object_full</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">PassingPath</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">types_object</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">make_default_array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lens_object_full</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">make_default_array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">])</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.lens_norm"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.lens_norm">[docs]</a>    <span class="k">def</span> <span class="nf">lens_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns normalized lengths calculated by :meth:`lens`.</span>

<span class="sd">        Applied normalization is twofold:</span>

<span class="sd">        #. All lengths are divided by maximal length, and</span>
<span class="sd">        #. All lengths are subjected to :func:`pow` function with p = :attr:`bias_long`.</span>

<span class="sd">        :return: Normalized total (or `object` part) lengths of all paths.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>  <span class="c1"># normalize</span>
            <span class="k">return</span> <span class="n">lens</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span>  <span class="c1"># bias to long paths</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.lens_real"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.lens_real">[docs]</a>    <span class="k">def</span> <span class="nf">lens_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns real lengths of all paths.</span>

<span class="sd">        :return: Sizes of all paths.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">]</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.full_size"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.full_size">[docs]</a>    <span class="k">def</span> <span class="nf">full_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns desired size of master path.</span>

<span class="sd">        :return: Size of master path.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check what is the size of paths in all parts and normalize and then scale them</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
            <span class="c1"># lengths of all paths of part part</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="n">make_default_array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">part</span><span class="p">])</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lens</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>  <span class="c1"># normalization</span>
                <span class="n">lens</span> <span class="o">=</span> <span class="n">lens</span>  <span class="c1"># ** self.bias_long  # scale them by increasing weights of long paths</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># weighted average by paths lengths</span>
                <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">part</span><span class="p">])</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lens</span><span class="p">)))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Full size is </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># total size (desired), min 30 - a good low limit default?</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.simple_types_distribution"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.simple_types_distribution">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">simple_types_distribution</span><span class="p">(</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates normalized sizes of incoming, object, and outgoing parts of spath using generic types.</span>

<span class="sd">        It is assumed that spath has object part.</span>

<span class="sd">        :param list types: List of generic types.</span>
<span class="sd">        :rtype: 3 element list</span>
<span class="sd">        :return: Normalized sizes of incomin, object, and outgoing parts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># possible types are:</span>
        <span class="c1"># GenericPathTypeCodes.object_name</span>
        <span class="c1"># GenericPathTypeCodes.scope_name</span>
        <span class="n">td_in</span><span class="p">,</span> <span class="n">td_obj</span><span class="p">,</span> <span class="n">td_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">sls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list_blocks_to_slices</span><span class="p">(</span><span class="n">types</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
            <span class="c1"># this is input part</span>
            <span class="n">td_in</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="c1"># this is output part</span>
            <span class="n">td_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="c1"># the rest is object</span>
        <span class="n">td_obj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">-</span> <span class="n">td_in</span> <span class="o">-</span> <span class="n">td_out</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">td_in</span><span class="p">,</span> <span class="n">td_obj</span><span class="p">,</span> <span class="n">td_out</span><span class="p">)]</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.types_distribution"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.types_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">types_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: numpy.matrix</span>
<span class="sd">        :return: median values of :meth:`simple_types_distribution` for all spaths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make median distribuitions</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">make_default_array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simple_types_distribution</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">gtypes_cont</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.types_prob_to_types"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.types_prob_to_types">[docs]</a>    <span class="k">def</span> <span class="nf">types_prob_to_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types_prob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes types probabilities as returned by :meth:`CTypeSpathsCollectionWorker.coords_types_prob_widths` to types.</span>

<span class="sd">        :param list types_prob: List of types probabilities.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :return: List of :class:`~aquaduct.traj.paths.GenericPathTypeCodes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get proper types</span>
        <span class="n">types_dist_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">types_distribution</span><span class="p">()</span>
        <span class="n">types_dist_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">types_prob</span><span class="p">))</span>
        <span class="n">types_thresholds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types_dist_range</span><span class="p">:</span>
            <span class="n">new_pro_types</span> <span class="o">=</span> <span class="p">[{</span><span class="kc">True</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">,</span>
                              <span class="kc">False</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">object_name</span><span class="p">}[</span><span class="n">typ</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types_prob</span><span class="p">]</span>
            <span class="n">types_thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_default_array</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simple_types_distribution</span><span class="p">(</span><span class="n">new_pro_types</span><span class="p">)),</span>
                                                             <span class="n">types_dist_orig</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>
        <span class="c1"># get threshold for which value of types_thresholds is smallest</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[{</span><span class="kc">True</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">,</span>
                  <span class="kc">False</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">object_name</span><span class="p">}[</span><span class="n">typ</span> <span class="o">&gt;=</span> <span class="n">types_dist_range</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">types_thresholds</span><span class="p">)]]</span> <span class="k">for</span> <span class="n">typ</span>
                 <span class="ow">in</span> <span class="n">types_prob</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">types</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.get_master_path"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.get_master_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_master_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resid</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. _master_path_generation:</span>

<span class="sd">        Averages spaths into one master path.</span>

<span class="sd">        This is done in steps:</span>

<span class="sd">        #. Master path is an average of bunch of spaths. Its length is determined by :meth:`full_size` method.</span>
<span class="sd">        #. All spaths are then divided in to chunks according to :func:`~aquaduct.utils.helpers.xzip_xzip` function with :attr:`N` set to lenght of master path. This results in list of length equal to the length of master path. Elements of this lists are slice objects that can be used to slice spaths in appropriate chunks.</span>
<span class="sd">        #. Next, for each element of this list :meth:`CTypeSpathsCollectionWorker.coords_types_prob_widths` method is called. Types probabilities are changed to types wiht :meth:`types_prob_to_types`.</span>
<span class="sd">        #. Finally, all data are used to create appropriate :class:`MasterPath`. If this fails `None` is returned.</span>

<span class="sd">        :param Smooth smooth: Smoothing method.</span>
<span class="sd">        :param int resid: Residue ID of master path.</span>
<span class="sd">        :rtype: :class:`~aquaduct.traj.paths.MasterPath`</span>
<span class="sd">        :return: Average path as :class:`~aquaduct.traj.paths.MasterPath` object or `None` if creation of master path failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prepare worker</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="n">CTypeSpathsCollectionWorker</span><span class="p">(</span><span class="n">spaths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span> <span class="n">bias_long</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span><span class="p">,</span>
                                             <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
        <span class="c1"># add some spaths precalcualted properties to worker</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">lens_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">lens_real_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_real_cache</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">lens_norm_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm_cache</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">full_size_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span>
        <span class="c1"># worker.lock_required = GCS.cachemem or GCS.cachedir</span>

        <span class="c1"># desired full size of path</span>
        <span class="n">full_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span>

        <span class="c1"># containers for coords, types and widths of master path</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">full_size</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">full_size</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">full_size</span>

        <span class="c1"># pbar magic</span>
        <span class="n">pbar_previous</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pbar_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">))</span> <span class="o">/</span> <span class="n">full_size</span>

        <span class="c1"># create pool of workers - mapping function</span>
        <span class="n">map_fun</span> <span class="o">=</span> <span class="nb">map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">)</span>
            <span class="n">map_fun</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">full_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chunk_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># map_fun = partial(pool.imap_unordered, chunksize=chunk_size)</span>
            <span class="n">map_fun</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>

        <span class="c1"># TODO: it is possible to add pbar support here!</span>
        <span class="c1"># maximal number of spath</span>
        <span class="n">spath_nr_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># loop over results of workers calculations on xzip_xzip lens_real with N=full_size</span>
        <span class="c1"># 1. Lens_real (sizes of spaths) are submitted to xzip_xzip wih N=full size</span>
        <span class="c1">#    For each spath there will be collection of N slices, each slice cuts some part of spath.</span>
        <span class="c1">#    In consequence, all spaths will be cutted in tho N chunks and for each path chunk will be</span>
        <span class="c1">#    of different size</span>
        <span class="c1"># 2. These slices are submitted to worker callable class.</span>
        <span class="k">for</span> <span class="n">pbar_nr</span><span class="p">,</span> <span class="p">(</span><span class="n">spath_nr</span><span class="p">,</span> <span class="p">(</span><span class="n">coords_</span><span class="p">,</span> <span class="n">types_</span><span class="p">,</span> <span class="n">widths_</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">map_fun</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xzip_xzip</span><span class="p">(</span><span class="o">*</span><span class="n">worker</span><span class="o">.</span><span class="n">lens_real_cache</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">full_size</span><span class="p">)))):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">spath_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_</span>
            <span class="n">types</span><span class="p">[</span><span class="n">spath_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">types_</span>
            <span class="n">widths</span><span class="p">[</span><span class="n">spath_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths_</span>
            <span class="n">spath_nr_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">spath_nr</span><span class="p">,</span> <span class="n">spath_nr_max</span><span class="p">)</span>
            <span class="n">pbar_current</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">pbar_nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pbar_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pbar_current</span> <span class="o">&gt;</span> <span class="n">pbar_previous</span><span class="p">:</span>
                <span class="n">pbar_previous</span> <span class="o">=</span> <span class="n">pbar_current</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>  <span class="c1"># update progress bar</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">pbar_nr</span> <span class="o">==</span> <span class="n">spath_nr_max</span><span class="p">,</span> <span class="s2">&quot;Internal error. Final global progress of master path generation not synced with maximal number of spath. Please send a bug report to developer(s): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">clui</span><span class="o">.</span><span class="n">mail</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">pool</span>

        <span class="c1"># at this stage we have coords, widths and types probability</span>

        <span class="c1"># get proper types</span>
        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;proper tests in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="n">types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">types_prob_to_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

        <span class="c1"># make frames</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

        <span class="c1"># finalize</span>

        <span class="c1"># max min frames</span>
        <span class="n">min_pf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_pf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># this never happens because of assertion in __init__</span>
            <span class="n">min_pf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">max_pf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_pf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_pf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;generic paths in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="c1"># get and populate GenericPath</span>
            <span class="n">fsrs_cache</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">resid</span><span class="p">:</span> <span class="n">FakeSingleResidueSelection</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">coords</span><span class="p">)})</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">GenericPaths</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">min_pf</span><span class="o">=</span><span class="n">min_pf</span><span class="p">,</span> <span class="n">max_pf</span><span class="o">=</span><span class="n">max_pf</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">frames</span><span class="p">):</span>  <span class="c1"># TODO: remove loop</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="c1"># now try to get first SinglePath, if unable issue WARNING</span>
        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;separate paths in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">yield_single_paths</span><span class="p">([</span><span class="n">gp</span><span class="p">],</span> <span class="n">passing</span><span class="o">=</span><span class="kc">False</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No master path found for ctype </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># finally get MasterPath and add widths</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">MasterPath</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">single_res_selection</span><span class="o">=</span><span class="n">fsrs_cache</span><span class="p">[</span><span class="n">resid</span><span class="p">])</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">add_width</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mp</span></div></div>


<span class="c1"># fake single residue type like object</span>
<span class="kn">from</span> <span class="nn">aquaduct.traj.sandwich</span> <span class="k">import</span> <span class="n">SingleResidueSelection</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils.helpers</span> <span class="k">import</span> <span class="n">arrayify</span>


<span class="k">class</span> <span class="nc">FakeSingleResidueSelection</span><span class="p">(</span><span class="n">SingleResidueSelection</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FakeSingleResidueSelection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frames</span> <span class="o">=</span> <span class="n">frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span> <span class="o">=</span> <span class="n">coords</span>

    <span class="nd">@arrayify</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frames</span><span class="p">):</span>
        <span class="c1"># return coords for frames</span>
        <span class="c1"># assume that frames are in _frames</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coords</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>

    <span class="c1"># TODO: This part of the code is weak. Change it, here and as well as in sandwich.</span>
    <span class="k">def</span> <span class="nf">coords_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sranges</span><span class="p">,</span> <span class="n">smooth</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">srange</span> <span class="ow">in</span> <span class="n">sranges</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">smooth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">srange</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/AQUADUCT_LOGO.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Aqua-Duct 1.0.10 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../aquaduct.html" >aquaduct</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geom.html" >aquaduct.geom</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">aquaduct.geom.master</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, 2017, 2018, 2019 Tomasz Magdziarz, Karolina Mitusińska, Agata Raczyńska, Artur Góra.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>